
obj/rubyvm4ij.axf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000208  00007000  00007000  00007000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text.irep_get 000000aa  00007208  00007208  00007208  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text.irep_atol 00000030  000072b2  000072b2  000072b2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text.mrb_strcmp 00000016  000072e2  000072e2  000072e2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .text.mrb_memory_find 0000003a  000072f8  000072f8  000072f8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .text.mrb_memory_add 0000003c  00007332  00007332  00007332  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.emb_method 00000144  00007370  00007370  00007370  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.irep_exec 00000460  000074b4  000074b4  000074b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .rodata.emb_method.str1.1 00000029  00007914  00007914  00007914  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .rodata.irep_exec.str1.1 0000000b  0000793d  0000793d  0000793d  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .debug_info   00000eeb  00000000  00000000  00007948  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000003e5  00000000  00000000  00008833  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000178d  00000000  00000000  00008c18  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00000060  00000000  00000000  0000a3a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000001f0  00000000  00000000  0000a405  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   000002f0  00000000  00000000  0000a5f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00000629  00000000  00000000  0000a8e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007f  00000000  00000000  0000af0e  2**0
                  CONTENTS, READONLY
 18 .ARM.attributes 00000031  00000000  00000000  0000af8d  2**0
                  CONTENTS, READONLY
 19 .debug_frame  00000134  00000000  00000000  0000afc0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <main>:
__attribute__ ((section(".main")))
int main(int param, int ram, int rom, uint64_t (*divfunc)()) {
	//uint8_t* mrbfile = (uint8_t*)ram + 0x700; // under 256byte
	uint8_t* mrbfile = (uint8_t*)0x6400; // sector6-1, limit 3kb
	struct mrb_vm vm;
	mrb_vm_init(&vm);
    7000:	2200      	movs	r2, #0
int main(int param, int ram, int rom, uint64_t (*divfunc)()) {
    7002:	b500      	push	{lr}
    7004:	b0c1      	sub	sp, #260	; 0x104
	return mrb_run(&vm, mrbfile);
    7006:	0013      	movs	r3, r2
    7008:	4903      	ldr	r1, [pc, #12]	; (7018 <main+0x18>)
    700a:	a801      	add	r0, sp, #4
	mrb_vm_init(&vm);
    700c:	9201      	str	r2, [sp, #4]
    700e:	9202      	str	r2, [sp, #8]
	return mrb_run(&vm, mrbfile);
    7010:	f000 fa50 	bl	74b4 <irep_exec>
}
    7014:	b041      	add	sp, #260	; 0x104
    7016:	bd00      	pop	{pc}
    7018:	00006422 	.word	0x00006422

0000701c <__gnu_thumb1_case_uhi>:
    701c:	b403      	push	{r0, r1}
    701e:	4671      	mov	r1, lr
    7020:	0849      	lsrs	r1, r1, #1
    7022:	0040      	lsls	r0, r0, #1
    7024:	0049      	lsls	r1, r1, #1
    7026:	5a09      	ldrh	r1, [r1, r0]
    7028:	0049      	lsls	r1, r1, #1
    702a:	448e      	add	lr, r1
    702c:	bc03      	pop	{r0, r1}
    702e:	4770      	bx	lr

00007030 <__divsi3>:
    7030:	4603      	mov	r3, r0
    7032:	430b      	orrs	r3, r1
    7034:	d47f      	bmi.n	7136 <__divsi3+0x106>
    7036:	2200      	movs	r2, #0
    7038:	0843      	lsrs	r3, r0, #1
    703a:	428b      	cmp	r3, r1
    703c:	d374      	bcc.n	7128 <__divsi3+0xf8>
    703e:	0903      	lsrs	r3, r0, #4
    7040:	428b      	cmp	r3, r1
    7042:	d35f      	bcc.n	7104 <__divsi3+0xd4>
    7044:	0a03      	lsrs	r3, r0, #8
    7046:	428b      	cmp	r3, r1
    7048:	d344      	bcc.n	70d4 <__divsi3+0xa4>
    704a:	0b03      	lsrs	r3, r0, #12
    704c:	428b      	cmp	r3, r1
    704e:	d328      	bcc.n	70a2 <__divsi3+0x72>
    7050:	0c03      	lsrs	r3, r0, #16
    7052:	428b      	cmp	r3, r1
    7054:	d30d      	bcc.n	7072 <__divsi3+0x42>
    7056:	22ff      	movs	r2, #255	; 0xff
    7058:	0209      	lsls	r1, r1, #8
    705a:	ba12      	rev	r2, r2
    705c:	0c03      	lsrs	r3, r0, #16
    705e:	428b      	cmp	r3, r1
    7060:	d302      	bcc.n	7068 <__divsi3+0x38>
    7062:	1212      	asrs	r2, r2, #8
    7064:	0209      	lsls	r1, r1, #8
    7066:	d065      	beq.n	7134 <__divsi3+0x104>
    7068:	0b03      	lsrs	r3, r0, #12
    706a:	428b      	cmp	r3, r1
    706c:	d319      	bcc.n	70a2 <__divsi3+0x72>
    706e:	e000      	b.n	7072 <__divsi3+0x42>
    7070:	0a09      	lsrs	r1, r1, #8
    7072:	0bc3      	lsrs	r3, r0, #15
    7074:	428b      	cmp	r3, r1
    7076:	d301      	bcc.n	707c <__divsi3+0x4c>
    7078:	03cb      	lsls	r3, r1, #15
    707a:	1ac0      	subs	r0, r0, r3
    707c:	4152      	adcs	r2, r2
    707e:	0b83      	lsrs	r3, r0, #14
    7080:	428b      	cmp	r3, r1
    7082:	d301      	bcc.n	7088 <__divsi3+0x58>
    7084:	038b      	lsls	r3, r1, #14
    7086:	1ac0      	subs	r0, r0, r3
    7088:	4152      	adcs	r2, r2
    708a:	0b43      	lsrs	r3, r0, #13
    708c:	428b      	cmp	r3, r1
    708e:	d301      	bcc.n	7094 <__divsi3+0x64>
    7090:	034b      	lsls	r3, r1, #13
    7092:	1ac0      	subs	r0, r0, r3
    7094:	4152      	adcs	r2, r2
    7096:	0b03      	lsrs	r3, r0, #12
    7098:	428b      	cmp	r3, r1
    709a:	d301      	bcc.n	70a0 <__divsi3+0x70>
    709c:	030b      	lsls	r3, r1, #12
    709e:	1ac0      	subs	r0, r0, r3
    70a0:	4152      	adcs	r2, r2
    70a2:	0ac3      	lsrs	r3, r0, #11
    70a4:	428b      	cmp	r3, r1
    70a6:	d301      	bcc.n	70ac <__divsi3+0x7c>
    70a8:	02cb      	lsls	r3, r1, #11
    70aa:	1ac0      	subs	r0, r0, r3
    70ac:	4152      	adcs	r2, r2
    70ae:	0a83      	lsrs	r3, r0, #10
    70b0:	428b      	cmp	r3, r1
    70b2:	d301      	bcc.n	70b8 <__divsi3+0x88>
    70b4:	028b      	lsls	r3, r1, #10
    70b6:	1ac0      	subs	r0, r0, r3
    70b8:	4152      	adcs	r2, r2
    70ba:	0a43      	lsrs	r3, r0, #9
    70bc:	428b      	cmp	r3, r1
    70be:	d301      	bcc.n	70c4 <__divsi3+0x94>
    70c0:	024b      	lsls	r3, r1, #9
    70c2:	1ac0      	subs	r0, r0, r3
    70c4:	4152      	adcs	r2, r2
    70c6:	0a03      	lsrs	r3, r0, #8
    70c8:	428b      	cmp	r3, r1
    70ca:	d301      	bcc.n	70d0 <__divsi3+0xa0>
    70cc:	020b      	lsls	r3, r1, #8
    70ce:	1ac0      	subs	r0, r0, r3
    70d0:	4152      	adcs	r2, r2
    70d2:	d2cd      	bcs.n	7070 <__divsi3+0x40>
    70d4:	09c3      	lsrs	r3, r0, #7
    70d6:	428b      	cmp	r3, r1
    70d8:	d301      	bcc.n	70de <__divsi3+0xae>
    70da:	01cb      	lsls	r3, r1, #7
    70dc:	1ac0      	subs	r0, r0, r3
    70de:	4152      	adcs	r2, r2
    70e0:	0983      	lsrs	r3, r0, #6
    70e2:	428b      	cmp	r3, r1
    70e4:	d301      	bcc.n	70ea <__divsi3+0xba>
    70e6:	018b      	lsls	r3, r1, #6
    70e8:	1ac0      	subs	r0, r0, r3
    70ea:	4152      	adcs	r2, r2
    70ec:	0943      	lsrs	r3, r0, #5
    70ee:	428b      	cmp	r3, r1
    70f0:	d301      	bcc.n	70f6 <__divsi3+0xc6>
    70f2:	014b      	lsls	r3, r1, #5
    70f4:	1ac0      	subs	r0, r0, r3
    70f6:	4152      	adcs	r2, r2
    70f8:	0903      	lsrs	r3, r0, #4
    70fa:	428b      	cmp	r3, r1
    70fc:	d301      	bcc.n	7102 <__divsi3+0xd2>
    70fe:	010b      	lsls	r3, r1, #4
    7100:	1ac0      	subs	r0, r0, r3
    7102:	4152      	adcs	r2, r2
    7104:	08c3      	lsrs	r3, r0, #3
    7106:	428b      	cmp	r3, r1
    7108:	d301      	bcc.n	710e <__divsi3+0xde>
    710a:	00cb      	lsls	r3, r1, #3
    710c:	1ac0      	subs	r0, r0, r3
    710e:	4152      	adcs	r2, r2
    7110:	0883      	lsrs	r3, r0, #2
    7112:	428b      	cmp	r3, r1
    7114:	d301      	bcc.n	711a <__divsi3+0xea>
    7116:	008b      	lsls	r3, r1, #2
    7118:	1ac0      	subs	r0, r0, r3
    711a:	4152      	adcs	r2, r2
    711c:	0843      	lsrs	r3, r0, #1
    711e:	428b      	cmp	r3, r1
    7120:	d301      	bcc.n	7126 <__divsi3+0xf6>
    7122:	004b      	lsls	r3, r1, #1
    7124:	1ac0      	subs	r0, r0, r3
    7126:	4152      	adcs	r2, r2
    7128:	1a41      	subs	r1, r0, r1
    712a:	d200      	bcs.n	712e <__divsi3+0xfe>
    712c:	4601      	mov	r1, r0
    712e:	4152      	adcs	r2, r2
    7130:	4610      	mov	r0, r2
    7132:	4770      	bx	lr
    7134:	e05d      	b.n	71f2 <__divsi3+0x1c2>
    7136:	0fca      	lsrs	r2, r1, #31
    7138:	d000      	beq.n	713c <__divsi3+0x10c>
    713a:	4249      	negs	r1, r1
    713c:	1003      	asrs	r3, r0, #32
    713e:	d300      	bcc.n	7142 <__divsi3+0x112>
    7140:	4240      	negs	r0, r0
    7142:	4053      	eors	r3, r2
    7144:	2200      	movs	r2, #0
    7146:	469c      	mov	ip, r3
    7148:	0903      	lsrs	r3, r0, #4
    714a:	428b      	cmp	r3, r1
    714c:	d32d      	bcc.n	71aa <__divsi3+0x17a>
    714e:	0a03      	lsrs	r3, r0, #8
    7150:	428b      	cmp	r3, r1
    7152:	d312      	bcc.n	717a <__divsi3+0x14a>
    7154:	22fc      	movs	r2, #252	; 0xfc
    7156:	0189      	lsls	r1, r1, #6
    7158:	ba12      	rev	r2, r2
    715a:	0a03      	lsrs	r3, r0, #8
    715c:	428b      	cmp	r3, r1
    715e:	d30c      	bcc.n	717a <__divsi3+0x14a>
    7160:	0189      	lsls	r1, r1, #6
    7162:	1192      	asrs	r2, r2, #6
    7164:	428b      	cmp	r3, r1
    7166:	d308      	bcc.n	717a <__divsi3+0x14a>
    7168:	0189      	lsls	r1, r1, #6
    716a:	1192      	asrs	r2, r2, #6
    716c:	428b      	cmp	r3, r1
    716e:	d304      	bcc.n	717a <__divsi3+0x14a>
    7170:	0189      	lsls	r1, r1, #6
    7172:	d03a      	beq.n	71ea <__divsi3+0x1ba>
    7174:	1192      	asrs	r2, r2, #6
    7176:	e000      	b.n	717a <__divsi3+0x14a>
    7178:	0989      	lsrs	r1, r1, #6
    717a:	09c3      	lsrs	r3, r0, #7
    717c:	428b      	cmp	r3, r1
    717e:	d301      	bcc.n	7184 <__divsi3+0x154>
    7180:	01cb      	lsls	r3, r1, #7
    7182:	1ac0      	subs	r0, r0, r3
    7184:	4152      	adcs	r2, r2
    7186:	0983      	lsrs	r3, r0, #6
    7188:	428b      	cmp	r3, r1
    718a:	d301      	bcc.n	7190 <__divsi3+0x160>
    718c:	018b      	lsls	r3, r1, #6
    718e:	1ac0      	subs	r0, r0, r3
    7190:	4152      	adcs	r2, r2
    7192:	0943      	lsrs	r3, r0, #5
    7194:	428b      	cmp	r3, r1
    7196:	d301      	bcc.n	719c <__divsi3+0x16c>
    7198:	014b      	lsls	r3, r1, #5
    719a:	1ac0      	subs	r0, r0, r3
    719c:	4152      	adcs	r2, r2
    719e:	0903      	lsrs	r3, r0, #4
    71a0:	428b      	cmp	r3, r1
    71a2:	d301      	bcc.n	71a8 <__divsi3+0x178>
    71a4:	010b      	lsls	r3, r1, #4
    71a6:	1ac0      	subs	r0, r0, r3
    71a8:	4152      	adcs	r2, r2
    71aa:	08c3      	lsrs	r3, r0, #3
    71ac:	428b      	cmp	r3, r1
    71ae:	d301      	bcc.n	71b4 <__divsi3+0x184>
    71b0:	00cb      	lsls	r3, r1, #3
    71b2:	1ac0      	subs	r0, r0, r3
    71b4:	4152      	adcs	r2, r2
    71b6:	0883      	lsrs	r3, r0, #2
    71b8:	428b      	cmp	r3, r1
    71ba:	d301      	bcc.n	71c0 <__divsi3+0x190>
    71bc:	008b      	lsls	r3, r1, #2
    71be:	1ac0      	subs	r0, r0, r3
    71c0:	4152      	adcs	r2, r2
    71c2:	d2d9      	bcs.n	7178 <__divsi3+0x148>
    71c4:	0843      	lsrs	r3, r0, #1
    71c6:	428b      	cmp	r3, r1
    71c8:	d301      	bcc.n	71ce <__divsi3+0x19e>
    71ca:	004b      	lsls	r3, r1, #1
    71cc:	1ac0      	subs	r0, r0, r3
    71ce:	4152      	adcs	r2, r2
    71d0:	1a41      	subs	r1, r0, r1
    71d2:	d200      	bcs.n	71d6 <__divsi3+0x1a6>
    71d4:	4601      	mov	r1, r0
    71d6:	4663      	mov	r3, ip
    71d8:	4152      	adcs	r2, r2
    71da:	105b      	asrs	r3, r3, #1
    71dc:	4610      	mov	r0, r2
    71de:	d301      	bcc.n	71e4 <__divsi3+0x1b4>
    71e0:	4240      	negs	r0, r0
    71e2:	2b00      	cmp	r3, #0
    71e4:	d500      	bpl.n	71e8 <__divsi3+0x1b8>
    71e6:	4249      	negs	r1, r1
    71e8:	4770      	bx	lr
    71ea:	4663      	mov	r3, ip
    71ec:	105b      	asrs	r3, r3, #1
    71ee:	d300      	bcc.n	71f2 <__divsi3+0x1c2>
    71f0:	4240      	negs	r0, r0
    71f2:	b501      	push	{r0, lr}
    71f4:	2000      	movs	r0, #0
    71f6:	f000 f805 	bl	7204 <__aeabi_idiv0>
    71fa:	bd02      	pop	{r1, pc}

000071fc <__aeabi_idivmod>:
    71fc:	2900      	cmp	r1, #0
    71fe:	d0f8      	beq.n	71f2 <__divsi3+0x1c2>
    7200:	e716      	b.n	7030 <__divsi3>
    7202:	4770      	bx	lr

00007204 <__aeabi_idiv0>:
    7204:	4770      	bx	lr
    7206:	46c0      	nop			; (mov r8, r8)

Disassembly of section .text.irep_get:

00007208 <irep_get>:
#define IREP_TYPE_SYMBOL 2
#define IREP_TYPE_IREP 3

 // literal: type, len(big endian short), data... (no null terminate)
 // symbol : len(big endian short), data ... (with null terminate)
const uint8_t* irep_get(const uint8_t* p, int type, int n) {
    7208:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    720a:	0005      	movs	r5, r0
    720c:	7b03      	ldrb	r3, [r0, #12]
    720e:	7b40      	ldrb	r0, [r0, #13]
    7210:	0014      	movs	r4, r2
    7212:	0200      	lsls	r0, r0, #8
    7214:	4318      	orrs	r0, r3
	p += 8;
	int nirep = b2l2(p);
	p += 2;
	{
		int codelen = b2l4(p);
		p += 4;
    7216:	002b      	movs	r3, r5
		int align = (int)p & 3;
    7218:	2203      	movs	r2, #3
    721a:	ba40      	rev16	r0, r0
		p += 4;
    721c:	330e      	adds	r3, #14
    721e:	b280      	uxth	r0, r0
		int align = (int)p & 3;
    7220:	401a      	ands	r2, r3
		if (align) {
    7222:	d001      	beq.n	7228 <irep_get+0x20>
			p += 4 - align;
    7224:	1a9b      	subs	r3, r3, r2
    7226:	3304      	adds	r3, #4
		}
		p += codelen;
    7228:	1818      	adds	r0, r3, r0
    722a:	78c6      	ldrb	r6, [r0, #3]
    722c:	7883      	ldrb	r3, [r0, #2]
    722e:	0236      	lsls	r6, r6, #8
    7230:	4333      	orrs	r3, r6
	{
		int plen = b2l4(p);
		//x_printf("litlen: %d\n", plen);
		if (type == IREP_TYPE_LITERAL) {
			check(n >= 0 && n < plen);
			plen = n;
    7232:	0026      	movs	r6, r4
		if (type == IREP_TYPE_LITERAL) {
    7234:	2901      	cmp	r1, #1
    7236:	d001      	beq.n	723c <irep_get+0x34>
    7238:	ba5e      	rev16	r6, r3
    723a:	b2b6      	uxth	r6, r6
		}
		p += 4;
		for (int i = 0; i < plen; i++) {
    723c:	2200      	movs	r2, #0
		p += 4;
    723e:	3004      	adds	r0, #4
		for (int i = 0; i < plen; i++) {
    7240:	4296      	cmp	r6, r2
    7242:	dc1c      	bgt.n	727e <irep_get+0x76>
			uint8_t type = *p;
			uint16_t len = b2l2(p + 1);
			p += len + 3;
		}
		if (type == IREP_TYPE_LITERAL) {
    7244:	2901      	cmp	r1, #1
    7246:	d019      	beq.n	727c <irep_get+0x74>
    7248:	78c6      	ldrb	r6, [r0, #3]
    724a:	7883      	ldrb	r3, [r0, #2]
    724c:	0236      	lsls	r6, r6, #8
    724e:	4333      	orrs	r3, r6
	{
		int symlen = b2l4(p);
		//x_printf("symlen: %d\n", symlen);
		if (type == IREP_TYPE_SYMBOL) {
			check(n >= 0 && n < symlen);
			symlen = n;
    7250:	0026      	movs	r6, r4
		if (type == IREP_TYPE_SYMBOL) {
    7252:	2902      	cmp	r1, #2
    7254:	d001      	beq.n	725a <irep_get+0x52>
    7256:	ba5e      	rev16	r6, r3
    7258:	b2b6      	uxth	r6, r6
		}
		p += 4;
		for (int i = 0; i < symlen; i++) {
    725a:	2200      	movs	r2, #0
		p += 4;
    725c:	3004      	adds	r0, #4
		for (int i = 0; i < symlen; i++) {
    725e:	4296      	cmp	r6, r2
    7260:	dc17      	bgt.n	7292 <irep_get+0x8a>
			uint16_t len = b2l2(p);
			p += len + 3; // len + '¥0'
		}
		if (type == IREP_TYPE_SYMBOL) {
    7262:	2902      	cmp	r1, #2
    7264:	d00a      	beq.n	727c <irep_get+0x74>
    7266:	7a6b      	ldrb	r3, [r5, #9]
    7268:	7a2a      	ldrb	r2, [r5, #8]
    726a:	021b      	lsls	r3, r3, #8
    726c:	4313      	orrs	r3, r2
			return p;
		}
	}
	{
		//x_printf("n ireps: %d\n", nirep);
		if (type == IREP_TYPE_IREP) {
    726e:	2903      	cmp	r1, #3
    7270:	d001      	beq.n	7276 <irep_get+0x6e>
    7272:	ba5c      	rev16	r4, r3
    7274:	b2a4      	uxth	r4, r4
			check(n >= 0 && n < nirep);
			nirep = n;
		}
		for (int i = 0; i < nirep; i++) {
    7276:	2500      	movs	r5, #0
    7278:	42ac      	cmp	r4, r5
    727a:	dc14      	bgt.n	72a6 <irep_get+0x9e>
		if (type == IREP_TYPE_IREP) {
			return p;
		}
	}
	return p;
}
    727c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			p += len + 3;
    727e:	7883      	ldrb	r3, [r0, #2]
    7280:	7847      	ldrb	r7, [r0, #1]
    7282:	021b      	lsls	r3, r3, #8
    7284:	433b      	orrs	r3, r7
    7286:	ba5b      	rev16	r3, r3
    7288:	b29b      	uxth	r3, r3
    728a:	3303      	adds	r3, #3
    728c:	18c0      	adds	r0, r0, r3
		for (int i = 0; i < plen; i++) {
    728e:	3201      	adds	r2, #1
    7290:	e7d6      	b.n	7240 <irep_get+0x38>
			p += len + 3; // len + '¥0'
    7292:	7843      	ldrb	r3, [r0, #1]
    7294:	7807      	ldrb	r7, [r0, #0]
    7296:	021b      	lsls	r3, r3, #8
    7298:	433b      	orrs	r3, r7
    729a:	ba5b      	rev16	r3, r3
    729c:	b29b      	uxth	r3, r3
    729e:	3303      	adds	r3, #3
    72a0:	18c0      	adds	r0, r0, r3
		for (int i = 0; i < symlen; i++) {
    72a2:	3201      	adds	r2, #1
    72a4:	e7db      	b.n	725e <irep_get+0x56>
			p = irep_get(p, IREP_TYPE_SKIP, 0);
    72a6:	2200      	movs	r2, #0
    72a8:	0011      	movs	r1, r2
    72aa:	f7ff ffad 	bl	7208 <irep_get>
		for (int i = 0; i < nirep; i++) {
    72ae:	3501      	adds	r5, #1
    72b0:	e7e2      	b.n	7278 <irep_get+0x70>

Disassembly of section .text.irep_atol:

000072b2 <irep_atol>:

// for mrb 2.0 binary
#define mrb_getIREP(mrb) ((mrb) + 34)
#define mrb_run(vm, mrb) irep_exec((vm), mrb_getIREP(mrb), NULL, 0)

intptr_t irep_atol(const char* s) {
    72b2:	b510      	push	{r4, lr}
	int flg = 0;
	if (*s == '-') {
    72b4:	7802      	ldrb	r2, [r0, #0]
    72b6:	1c43      	adds	r3, r0, #1
		flg = 1;
    72b8:	2101      	movs	r1, #1
	if (*s == '-') {
    72ba:	2a2d      	cmp	r2, #45	; 0x2d
    72bc:	d003      	beq.n	72c6 <irep_atol+0x14>
	int flg = 0;
    72be:	2100      	movs	r1, #0
		s++;
	} else if (*s == '+') {
    72c0:	2a2b      	cmp	r2, #43	; 0x2b
    72c2:	d000      	beq.n	72c6 <irep_atol+0x14>
    72c4:	0003      	movs	r3, r0
		s++;
	}
	intptr_t n = 0;
    72c6:	2000      	movs	r0, #0
	for (;;) {
		int c = *s++;
		if (c < '0' || c > '9') {
			break;
		}
		n = n * 10 + (c - '0');
    72c8:	240a      	movs	r4, #10
		int c = *s++;
    72ca:	781a      	ldrb	r2, [r3, #0]
    72cc:	3301      	adds	r3, #1
		if (c < '0' || c > '9') {
    72ce:	3a30      	subs	r2, #48	; 0x30
    72d0:	2a09      	cmp	r2, #9
    72d2:	d802      	bhi.n	72da <irep_atol+0x28>
		n = n * 10 + (c - '0');
    72d4:	4360      	muls	r0, r4
    72d6:	1810      	adds	r0, r2, r0
	for (;;) {
    72d8:	e7f7      	b.n	72ca <irep_atol+0x18>
	}
	return flg ? -n : n;
    72da:	2900      	cmp	r1, #0
    72dc:	d000      	beq.n	72e0 <irep_atol+0x2e>
    72de:	4240      	negs	r0, r0
}
    72e0:	bd10      	pop	{r4, pc}

Disassembly of section .text.mrb_strcmp:

000072e2 <mrb_strcmp>:
int mrb_strcmp(const char* buf1, const char* buf2) {
    72e2:	2200      	movs	r2, #0
    72e4:	b510      	push	{r4, lr}
	for (;;) {
		int n = *buf1++;
    72e6:	5c84      	ldrb	r4, [r0, r2]
		int c = n - *buf2++;
    72e8:	5c8b      	ldrb	r3, [r1, r2]
    72ea:	1ae3      	subs	r3, r4, r3
		if (c)
    72ec:	d102      	bne.n	72f4 <mrb_strcmp+0x12>
    72ee:	3201      	adds	r2, #1
			return c;
		if (!n)
    72f0:	2c00      	cmp	r4, #0
    72f2:	d1f8      	bne.n	72e6 <mrb_strcmp+0x4>
			return 0;
	}
}
    72f4:	0018      	movs	r0, r3
    72f6:	bd10      	pop	{r4, pc}

Disassembly of section .text.mrb_memory_find:

000072f8 <mrb_memory_find>:
intptr_t* mrb_memory_find(struct mrb_vm* vm, intptr_t obj, const char* name) {
    72f8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	for (int i = 0; i < vm->nmemory * 3; i += 3) {
    72fa:	2303      	movs	r3, #3
intptr_t* mrb_memory_find(struct mrb_vm* vm, intptr_t obj, const char* name) {
    72fc:	9201      	str	r2, [sp, #4]
	for (int i = 0; i < vm->nmemory * 3; i += 3) {
    72fe:	6842      	ldr	r2, [r0, #4]
	intptr_t* mem = vm->memory;
    7300:	3008      	adds	r0, #8
intptr_t* mrb_memory_find(struct mrb_vm* vm, intptr_t obj, const char* name) {
    7302:	000f      	movs	r7, r1
	intptr_t* mem = vm->memory;
    7304:	0004      	movs	r4, r0
	for (int i = 0; i < vm->nmemory * 3; i += 3) {
    7306:	2500      	movs	r5, #0
    7308:	435a      	muls	r2, r3
    730a:	9200      	str	r2, [sp, #0]
    730c:	9b00      	ldr	r3, [sp, #0]
    730e:	42ab      	cmp	r3, r5
    7310:	dc02      	bgt.n	7318 <mrb_memory_find+0x20>
	return NULL;
    7312:	2600      	movs	r6, #0
}
    7314:	0030      	movs	r0, r6
    7316:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		if (mem[i] == obj && mrb_strcmp((const char*)mem[i + 1], name) == 0) {
    7318:	6823      	ldr	r3, [r4, #0]
    731a:	0026      	movs	r6, r4
    731c:	42bb      	cmp	r3, r7
    731e:	d105      	bne.n	732c <mrb_memory_find+0x34>
    7320:	9901      	ldr	r1, [sp, #4]
    7322:	6860      	ldr	r0, [r4, #4]
    7324:	f7ff ffdd 	bl	72e2 <mrb_strcmp>
    7328:	2800      	cmp	r0, #0
    732a:	d0f3      	beq.n	7314 <mrb_memory_find+0x1c>
	for (int i = 0; i < vm->nmemory * 3; i += 3) {
    732c:	3503      	adds	r5, #3
    732e:	340c      	adds	r4, #12
    7330:	e7ec      	b.n	730c <mrb_memory_find+0x14>

Disassembly of section .text.mrb_memory_add:

00007332 <mrb_memory_add>:
int mrb_memory_add(struct mrb_vm* vm, intptr_t obj, const char* name, intptr_t val) { // 0 when out of memory
    7332:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7334:	0004      	movs	r4, r0
    7336:	000f      	movs	r7, r1
    7338:	0016      	movs	r6, r2
    733a:	001d      	movs	r5, r3
	intptr_t* chk = mrb_memory_find(vm, obj, name);
    733c:	f7ff ffdc 	bl	72f8 <mrb_memory_find>
	if (chk) {
    7340:	2800      	cmp	r0, #0
    7342:	d002      	beq.n	734a <mrb_memory_add+0x18>
		chk[2] = val;
    7344:	6085      	str	r5, [r0, #8]
	return 1;
    7346:	2001      	movs	r0, #1
    7348:	e004      	b.n	7354 <mrb_memory_add+0x22>
	if (vm->nmemory == MAX_USERDEF) {
    734a:	6861      	ldr	r1, [r4, #4]
    734c:	2914      	cmp	r1, #20
    734e:	d102      	bne.n	7356 <mrb_memory_add+0x24>
		vm->err = MRB_ERR_EXCEED_MAX_USEROBJECT;
    7350:	2303      	movs	r3, #3
    7352:	6023      	str	r3, [r4, #0]
}
    7354:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	intptr_t* mem = vm->memory + vm->nmemory * 3;
    7356:	220c      	movs	r2, #12
    7358:	0023      	movs	r3, r4
    735a:	434a      	muls	r2, r1
    735c:	3308      	adds	r3, #8
    735e:	189b      	adds	r3, r3, r2
	*mem++ = obj;
    7360:	601f      	str	r7, [r3, #0]
	*mem++ = (intptr_t)name;
    7362:	605e      	str	r6, [r3, #4]
	*mem++ = val;
    7364:	609d      	str	r5, [r3, #8]
	vm->nmemory++;
    7366:	6863      	ldr	r3, [r4, #4]
    7368:	3301      	adds	r3, #1
    736a:	6063      	str	r3, [r4, #4]
    736c:	e7eb      	b.n	7346 <mrb_memory_add+0x14>

Disassembly of section .text.emb_method:

00007370 <emb_method>:
void emb_method(struct mrb_vm* vm, const char* func, intptr_t* reg, int a, int paramlen) {
    7370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7372:	000e      	movs	r6, r1
    7374:	0007      	movs	r7, r0
	if (mrb_strcmp(func, "cls") == 0) {
    7376:	4945      	ldr	r1, [pc, #276]	; (748c <emb_method+0x11c>)
    7378:	0030      	movs	r0, r6
void emb_method(struct mrb_vm* vm, const char* func, intptr_t* reg, int a, int paramlen) {
    737a:	0015      	movs	r5, r2
    737c:	001c      	movs	r4, r3
	if (mrb_strcmp(func, "cls") == 0) {
    737e:	f7ff ffb0 	bl	72e2 <mrb_strcmp>
    7382:	2800      	cmp	r0, #0
    7384:	d103      	bne.n	738e <emb_method+0x1e>
		cls();
    7386:	23cc      	movs	r3, #204	; 0xcc
    7388:	881b      	ldrh	r3, [r3, #0]
    738a:	4798      	blx	r3
}
    738c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (mrb_strcmp(func, "lc") == 0) {
    738e:	4940      	ldr	r1, [pc, #256]	; (7490 <emb_method+0x120>)
    7390:	0030      	movs	r0, r6
    7392:	f7ff ffa6 	bl	72e2 <mrb_strcmp>
    7396:	2800      	cmp	r0, #0
    7398:	d108      	bne.n	73ac <emb_method+0x3c>
		locate(reg[a + 1], reg[a + 2]);
    739a:	23ce      	movs	r3, #206	; 0xce
    739c:	3401      	adds	r4, #1
    739e:	00a4      	lsls	r4, r4, #2
    73a0:	192a      	adds	r2, r5, r4
    73a2:	881b      	ldrh	r3, [r3, #0]
    73a4:	6851      	ldr	r1, [r2, #4]
    73a6:	5928      	ldr	r0, [r5, r4]
		out(7, reg[a + 1]);
    73a8:	4798      	blx	r3
    73aa:	e7ef      	b.n	738c <emb_method+0x1c>
	} else if (mrb_strcmp(func, "scr") == 0) {
    73ac:	4939      	ldr	r1, [pc, #228]	; (7494 <emb_method+0x124>)
    73ae:	0030      	movs	r0, r6
    73b0:	f7ff ff97 	bl	72e2 <mrb_strcmp>
    73b4:	2800      	cmp	r0, #0
    73b6:	d10a      	bne.n	73ce <emb_method+0x5e>
		reg[a] = scr(reg[a + 1], reg[a + 2]);
    73b8:	23d0      	movs	r3, #208	; 0xd0
    73ba:	3401      	adds	r4, #1
    73bc:	00a4      	lsls	r4, r4, #2
    73be:	192e      	adds	r6, r5, r4
    73c0:	6871      	ldr	r1, [r6, #4]
    73c2:	881b      	ldrh	r3, [r3, #0]
    73c4:	5928      	ldr	r0, [r5, r4]
    73c6:	4798      	blx	r3
    73c8:	3e04      	subs	r6, #4
    73ca:	6030      	str	r0, [r6, #0]
    73cc:	e7de      	b.n	738c <emb_method+0x1c>
	} else if (mrb_strcmp(func, "inkey") == 0) {
    73ce:	4932      	ldr	r1, [pc, #200]	; (7498 <emb_method+0x128>)
    73d0:	0030      	movs	r0, r6
    73d2:	f7ff ff86 	bl	72e2 <mrb_strcmp>
    73d6:	2800      	cmp	r0, #0
    73d8:	d105      	bne.n	73e6 <emb_method+0x76>
		reg[a] = inkey();
    73da:	23ca      	movs	r3, #202	; 0xca
    73dc:	881b      	ldrh	r3, [r3, #0]
    73de:	4798      	blx	r3
    73e0:	00a4      	lsls	r4, r4, #2
    73e2:	5160      	str	r0, [r4, r5]
    73e4:	e7d2      	b.n	738c <emb_method+0x1c>
	} else if (mrb_strcmp(func, "rnd") == 0) {
    73e6:	492d      	ldr	r1, [pc, #180]	; (749c <emb_method+0x12c>)
    73e8:	0030      	movs	r0, r6
    73ea:	f7ff ff7a 	bl	72e2 <mrb_strcmp>
    73ee:	2800      	cmp	r0, #0
    73f0:	d109      	bne.n	7406 <emb_method+0x96>
		reg[a] = rnd(reg[a + 1]);
    73f2:	23c0      	movs	r3, #192	; 0xc0
    73f4:	3401      	adds	r4, #1
    73f6:	00a4      	lsls	r4, r4, #2
    73f8:	5928      	ldr	r0, [r5, r4]
    73fa:	881b      	ldrh	r3, [r3, #0]
    73fc:	4798      	blx	r3
    73fe:	192c      	adds	r4, r5, r4
    7400:	3c04      	subs	r4, #4
    7402:	6020      	str	r0, [r4, #0]
    7404:	e7c2      	b.n	738c <emb_method+0x1c>
	} else if (mrb_strcmp(func, "wait") == 0) {
    7406:	4926      	ldr	r1, [pc, #152]	; (74a0 <emb_method+0x130>)
    7408:	0030      	movs	r0, r6
    740a:	f7ff ff6a 	bl	72e2 <mrb_strcmp>
    740e:	2800      	cmp	r0, #0
    7410:	d106      	bne.n	7420 <emb_method+0xb0>
		wait(reg[a + 1]);
    7412:	23d6      	movs	r3, #214	; 0xd6
    7414:	3401      	adds	r4, #1
    7416:	00a4      	lsls	r4, r4, #2
		putstr((const char*)reg[a + 1]);
    7418:	881b      	ldrh	r3, [r3, #0]
    741a:	5960      	ldr	r0, [r4, r5]
    741c:	4798      	blx	r3
    741e:	e7b5      	b.n	738c <emb_method+0x1c>
	} else if (mrb_strcmp(func, "!=") == 0) {
    7420:	4920      	ldr	r1, [pc, #128]	; (74a4 <emb_method+0x134>)
    7422:	0030      	movs	r0, r6
    7424:	f7ff ff5d 	bl	72e2 <mrb_strcmp>
    7428:	2800      	cmp	r0, #0
    742a:	d10a      	bne.n	7442 <emb_method+0xd2>
		intptr_t ret = reg[a] != reg[a + 1] ? MRB_TRUE : MRB_FALSE;
    742c:	00a4      	lsls	r4, r4, #2
    742e:	192d      	adds	r5, r5, r4
    7430:	682a      	ldr	r2, [r5, #0]
    7432:	6869      	ldr	r1, [r5, #4]
    7434:	2301      	movs	r3, #1
    7436:	428a      	cmp	r2, r1
    7438:	d101      	bne.n	743e <emb_method+0xce>
    743a:	2380      	movs	r3, #128	; 0x80
    743c:	061b      	lsls	r3, r3, #24
		reg[a] = ret;
    743e:	602b      	str	r3, [r5, #0]
    7440:	e7a4      	b.n	738c <emb_method+0x1c>
	} else if (mrb_strcmp(func, "p") == 0) {
    7442:	4919      	ldr	r1, [pc, #100]	; (74a8 <emb_method+0x138>)
    7444:	0030      	movs	r0, r6
    7446:	f7ff ff4c 	bl	72e2 <mrb_strcmp>
    744a:	2800      	cmp	r0, #0
    744c:	d103      	bne.n	7456 <emb_method+0xe6>
		putc(reg[a + 1]);
    744e:	3401      	adds	r4, #1
    7450:	00a4      	lsls	r4, r4, #2
    7452:	23c4      	movs	r3, #196	; 0xc4
    7454:	e7e0      	b.n	7418 <emb_method+0xa8>
	} else if (mrb_strcmp(func, "print") == 0) {
    7456:	4915      	ldr	r1, [pc, #84]	; (74ac <emb_method+0x13c>)
    7458:	0030      	movs	r0, r6
    745a:	f7ff ff42 	bl	72e2 <mrb_strcmp>
    745e:	2800      	cmp	r0, #0
    7460:	d103      	bne.n	746a <emb_method+0xfa>
		putstr((const char*)reg[a + 1]);
    7462:	3401      	adds	r4, #1
    7464:	00a4      	lsls	r4, r4, #2
    7466:	23c8      	movs	r3, #200	; 0xc8
    7468:	e7d6      	b.n	7418 <emb_method+0xa8>
	} else if (mrb_strcmp(func, "led") == 0) {
    746a:	4911      	ldr	r1, [pc, #68]	; (74b0 <emb_method+0x140>)
    746c:	0030      	movs	r0, r6
    746e:	f7ff ff38 	bl	72e2 <mrb_strcmp>
    7472:	2800      	cmp	r0, #0
    7474:	d106      	bne.n	7484 <emb_method+0x114>
		out(7, reg[a + 1]);
    7476:	23d8      	movs	r3, #216	; 0xd8
    7478:	3401      	adds	r4, #1
    747a:	00a4      	lsls	r4, r4, #2
    747c:	881b      	ldrh	r3, [r3, #0]
    747e:	5961      	ldr	r1, [r4, r5]
    7480:	3007      	adds	r0, #7
    7482:	e791      	b.n	73a8 <emb_method+0x38>
		vm->err = MRB_ERR_NO_METHOD;
    7484:	2302      	movs	r3, #2
    7486:	603b      	str	r3, [r7, #0]
}
    7488:	e780      	b.n	738c <emb_method+0x1c>
    748a:	46c0      	nop			; (mov r8, r8)
    748c:	00007914 	.word	0x00007914
    7490:	00007918 	.word	0x00007918
    7494:	0000791b 	.word	0x0000791b
    7498:	0000791f 	.word	0x0000791f
    749c:	00007925 	.word	0x00007925
    74a0:	00007929 	.word	0x00007929
    74a4:	0000792e 	.word	0x0000792e
    74a8:	00007931 	.word	0x00007931
    74ac:	00007933 	.word	0x00007933
    74b0:	00007939 	.word	0x00007939

Disassembly of section .text.irep_exec:

000074b4 <irep_exec>:
int irep_exec(struct mrb_vm* vm, const uint8_t* irep, struct mrb_state* parent, int paramreg) {
    74b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    74b6:	b097      	sub	sp, #92	; 0x5c
    74b8:	af02      	add	r7, sp, #8
    74ba:	61fb      	str	r3, [r7, #28]
	intptr_t reg[nregs - 1]; // no need a reg for management
    74bc:	79cb      	ldrb	r3, [r1, #7]
int irep_exec(struct mrb_vm* vm, const uint8_t* irep, struct mrb_state* parent, int paramreg) {
    74be:	61ba      	str	r2, [r7, #24]
	intptr_t reg[nregs - 1]; // no need a reg for management
    74c0:	798a      	ldrb	r2, [r1, #6]
    74c2:	021b      	lsls	r3, r3, #8
    74c4:	4313      	orrs	r3, r2
    74c6:	466a      	mov	r2, sp
    74c8:	ba5b      	rev16	r3, r3
    74ca:	b29b      	uxth	r3, r3
    74cc:	009b      	lsls	r3, r3, #2
    74ce:	3306      	adds	r3, #6
    74d0:	08db      	lsrs	r3, r3, #3
    74d2:	00db      	lsls	r3, r3, #3
    74d4:	1ad3      	subs	r3, r2, r3
    74d6:	469d      	mov	sp, r3
		p += 4;
    74d8:	000b      	movs	r3, r1
    74da:	330e      	adds	r3, #14
    74dc:	627b      	str	r3, [r7, #36]	; 0x24
		int align = (int)p & 3;
    74de:	2303      	movs	r3, #3
    74e0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
int irep_exec(struct mrb_vm* vm, const uint8_t* irep, struct mrb_state* parent, int paramreg) {
    74e2:	62b8      	str	r0, [r7, #40]	; 0x28
    74e4:	62f9      	str	r1, [r7, #44]	; 0x2c
	intptr_t reg[nregs - 1]; // no need a reg for management
    74e6:	ad02      	add	r5, sp, #8
		int align = (int)p & 3;
    74e8:	4013      	ands	r3, r2
		if (align) {
    74ea:	d002      	beq.n	74f2 <irep_exec+0x3e>
			p += 4 - align;
    74ec:	1ad3      	subs	r3, r2, r3
    74ee:	3304      	adds	r3, #4
    74f0:	627b      	str	r3, [r7, #36]	; 0x24
	struct mrb_state state = { .parent = parent, .reg = reg };
    74f2:	69bb      	ldr	r3, [r7, #24]
    74f4:	63bd      	str	r5, [r7, #56]	; 0x38
    74f6:	637b      	str	r3, [r7, #52]	; 0x34
	reg[0] = paramreg ? parent->reg[paramreg] : MRB_OBJ_OBJECT; // self instance  0 means root object // vm->parentstate ? parentstate->caller : 0;
    74f8:	69fb      	ldr	r3, [r7, #28]
    74fa:	2101      	movs	r1, #1
    74fc:	2b00      	cmp	r3, #0
    74fe:	d006      	beq.n	750e <irep_exec+0x5a>
    7500:	69bb      	ldr	r3, [r7, #24]
    7502:	685b      	ldr	r3, [r3, #4]
    7504:	623b      	str	r3, [r7, #32]
    7506:	69fb      	ldr	r3, [r7, #28]
    7508:	6a3a      	ldr	r2, [r7, #32]
    750a:	009b      	lsls	r3, r3, #2
    750c:	5899      	ldr	r1, [r3, r2]
    750e:	6029      	str	r1, [r5, #0]
	intptr_t* tclass = mrb_memory_find(vm, reg[0], "_cls");
    7510:	4ab2      	ldr	r2, [pc, #712]	; (77dc <irep_exec+0x328>)
    7512:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    7514:	f7ff fef0 	bl	72f8 <mrb_memory_find>
    7518:	69fb      	ldr	r3, [r7, #28]
    751a:	6a7c      	ldr	r4, [r7, #36]	; 0x24
    751c:	009b      	lsls	r3, r3, #2
    751e:	617b      	str	r3, [r7, #20]
    7520:	1aeb      	subs	r3, r5, r3
    7522:	60bb      	str	r3, [r7, #8]
	int opext = 0;
    7524:	2300      	movs	r3, #0
    7526:	613b      	str	r3, [r7, #16]
		uint8_t op = *p++;
    7528:	7823      	ldrb	r3, [r4, #0]
    752a:	1c66      	adds	r6, r4, #1
		switch (op) {
    752c:	2b67      	cmp	r3, #103	; 0x67
    752e:	d900      	bls.n	7532 <irep_exec+0x7e>
    7530:	e1ec      	b.n	790c <irep_exec+0x458>
    7532:	0018      	movs	r0, r3
    7534:	f7ff fd72 	bl	701c <__gnu_thumb1_case_uhi>
    7538:	0068008a 	.word	0x0068008a
    753c:	007b0070 	.word	0x007b0070
    7540:	0091007b 	.word	0x0091007b
    7544:	00910091 	.word	0x00910091
    7548:	00910091 	.word	0x00910091
    754c:	00910091 	.word	0x00910091
    7550:	00910091 	.word	0x00910091
    7554:	00a20097 	.word	0x00a20097
    7558:	00a801e2 	.word	0x00a801e2
    755c:	01ea00a8 	.word	0x01ea00a8
    7560:	01ea01ea 	.word	0x01ea01ea
    7564:	01ea01ea 	.word	0x01ea01ea
    7568:	01ea01ea 	.word	0x01ea01ea
    756c:	01ea01ea 	.word	0x01ea01ea
    7570:	01ea01ea 	.word	0x01ea01ea
    7574:	00af01ea 	.word	0x00af01ea
    7578:	00c600af 	.word	0x00c600af
    757c:	00cf00cf 	.word	0x00cf00cf
    7580:	01ea01ea 	.word	0x01ea01ea
    7584:	01ea01ea 	.word	0x01ea01ea
    7588:	01ea01ea 	.word	0x01ea01ea
    758c:	01ea01ea 	.word	0x01ea01ea
    7590:	01ea01ea 	.word	0x01ea01ea
    7594:	010400e0 	.word	0x010400e0
    7598:	01ea01ea 	.word	0x01ea01ea
    759c:	013901ea 	.word	0x013901ea
    75a0:	01ea01ea 	.word	0x01ea01ea
    75a4:	015601ea 	.word	0x015601ea
    75a8:	01560156 	.word	0x01560156
    75ac:	015c01ea 	.word	0x015c01ea
    75b0:	016c0165 	.word	0x016c0165
    75b4:	017c0174 	.word	0x017c0174
    75b8:	018d0184 	.word	0x018d0184
    75bc:	01a40199 	.word	0x01a40199
    75c0:	01ba01af 	.word	0x01ba01af
    75c4:	01ea01ea 	.word	0x01ea01ea
    75c8:	01ea01ea 	.word	0x01ea01ea
    75cc:	01ea01ea 	.word	0x01ea01ea
    75d0:	01ea01ea 	.word	0x01ea01ea
    75d4:	01c501ea 	.word	0x01c501ea
    75d8:	01ea01c9 	.word	0x01ea01c9
    75dc:	01ea01ea 	.word	0x01ea01ea
    75e0:	01cb01ea 	.word	0x01cb01ea
    75e4:	01ea01cb 	.word	0x01ea01cb
    75e8:	01ea01ea 	.word	0x01ea01ea
    75ec:	01ea01ea 	.word	0x01ea01ea
    75f0:	01d201ea 	.word	0x01d201ea
    75f4:	01ea01ea 	.word	0x01ea01ea
    75f8:	01e201ea 	.word	0x01e201ea
    75fc:	01ea01ea 	.word	0x01ea01ea
    7600:	01e701e7 	.word	0x01e701e7
    7604:	01ec01e7 	.word	0x01ec01e7
				a = *p++; b = *p++;
    7608:	78a3      	ldrb	r3, [r4, #2]
    760a:	1ce6      	adds	r6, r4, #3
				reg[a] = reg[b];
    760c:	009b      	lsls	r3, r3, #2
    760e:	595a      	ldr	r2, [r3, r5]
				a = *p++; b = *p++;
    7610:	7863      	ldrb	r3, [r4, #1]
				reg[a] = reg[b];
    7612:	009b      	lsls	r3, r3, #2
				reg[a] = MRB_NIL;
    7614:	515a      	str	r2, [r3, r5]
				break;
    7616:	e019      	b.n	764c <irep_exec+0x198>
				a = *p++; b = *p++;
    7618:	78a2      	ldrb	r2, [r4, #2]
				reg[a] = irep_atol((const char*)(irep_get(irep, IREP_TYPE_LITERAL, b) + 3));
    761a:	2101      	movs	r1, #1
    761c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    761e:	f7ff fdf3 	bl	7208 <irep_get>
    7622:	3003      	adds	r0, #3
				a = *p++; b = *p++;
    7624:	1ce6      	adds	r6, r4, #3
				reg[a] = irep_atol((const char*)(irep_get(irep, IREP_TYPE_LITERAL, b) + 3));
    7626:	f7ff fe44 	bl	72b2 <irep_atol>
				a = *p++; b = *p++;
    762a:	7863      	ldrb	r3, [r4, #1]
    762c:	e07d      	b.n	772a <irep_exec+0x276>
				if (opext == 2)
    762e:	6938      	ldr	r0, [r7, #16]
				a = *p++; b = *p++;
    7630:	7861      	ldrb	r1, [r4, #1]
    7632:	78a2      	ldrb	r2, [r4, #2]
    7634:	1ce6      	adds	r6, r4, #3
				if (opext == 2)
    7636:	2802      	cmp	r0, #2
    7638:	d103      	bne.n	7642 <irep_exec+0x18e>
					b = (b << 8) + *p++;
    763a:	78e0      	ldrb	r0, [r4, #3]
    763c:	0212      	lsls	r2, r2, #8
    763e:	1d26      	adds	r6, r4, #4
    7640:	1882      	adds	r2, r0, r2
				if (op == OP_LOADINEG)
    7642:	2b04      	cmp	r3, #4
    7644:	d100      	bne.n	7648 <irep_exec+0x194>
					b = -b;
    7646:	4252      	negs	r2, r2
				reg[a] = b;
    7648:	0089      	lsls	r1, r1, #2
    764a:	514a      	str	r2, [r1, r5]
		if (vm->err) {
    764c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    764e:	6818      	ldr	r0, [r3, #0]
    7650:	2800      	cmp	r0, #0
    7652:	d000      	beq.n	7656 <irep_exec+0x1a2>
    7654:	e0c9      	b.n	77ea <irep_exec+0x336>
    7656:	0034      	movs	r4, r6
    7658:	e766      	b.n	7528 <irep_exec+0x74>
				a = *p++;
    765a:	7862      	ldrb	r2, [r4, #1]
    765c:	1ca6      	adds	r6, r4, #2
				reg[a] = op - OP_LOADI_0;
    765e:	0092      	lsls	r2, r2, #2
    7660:	3b06      	subs	r3, #6
					reg[a] = s->reg[b];
    7662:	50ab      	str	r3, [r5, r2]
    7664:	e7f2      	b.n	764c <irep_exec+0x198>
				reg[a] = (intptr_t)(irep_get(irep, IREP_TYPE_SYMBOL, b) + 2);
    7666:	2102      	movs	r1, #2
				a = *p++; b = *p++;
    7668:	78a2      	ldrb	r2, [r4, #2]
    766a:	1ce6      	adds	r6, r4, #3
				reg[a] = (intptr_t)(irep_get(irep, IREP_TYPE_SYMBOL, b) + 2);
    766c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    766e:	f7ff fdcb 	bl	7208 <irep_get>
				a = *p++; b = *p++;
    7672:	7863      	ldrb	r3, [r4, #1]
				reg[a] = (intptr_t)(irep_get(irep, IREP_TYPE_SYMBOL, b) + 2);
    7674:	3002      	adds	r0, #2
    7676:	009b      	lsls	r3, r3, #2
    7678:	5158      	str	r0, [r3, r5]
				break;
    767a:	e7e7      	b.n	764c <irep_exec+0x198>
				reg[a] = MRB_NIL;
    767c:	2280      	movs	r2, #128	; 0x80
				a = *p++;
    767e:	7863      	ldrb	r3, [r4, #1]
    7680:	1ca6      	adds	r6, r4, #2
				reg[a] = MRB_NIL;
    7682:	009b      	lsls	r3, r3, #2
    7684:	0612      	lsls	r2, r2, #24
    7686:	e7c5      	b.n	7614 <irep_exec+0x160>
				a = *p++;
    7688:	7862      	ldrb	r2, [r4, #1]
				reg[a] = op == OP_LOADT;
    768a:	3b11      	subs	r3, #17
				a = *p++;
    768c:	1ca6      	adds	r6, r4, #2
				reg[a] = op == OP_LOADT;
    768e:	0092      	lsls	r2, r2, #2
    7690:	4259      	negs	r1, r3
    7692:	414b      	adcs	r3, r1
    7694:	e7e5      	b.n	7662 <irep_exec+0x1ae>
				a = *p++; b = *p++; c = *p++;
    7696:	78e0      	ldrb	r0, [r4, #3]
    7698:	7862      	ldrb	r2, [r4, #1]
    769a:	78a1      	ldrb	r1, [r4, #2]
    769c:	1d26      	adds	r6, r4, #4
				for (int iu = 0; iu < c; iu++) {
    769e:	2400      	movs	r4, #0
				a = *p++; b = *p++; c = *p++;
    76a0:	4684      	mov	ip, r0
				struct mrb_state* s = state.parent;
    76a2:	6b78      	ldr	r0, [r7, #52]	; 0x34
				for (int iu = 0; iu < c; iu++) {
    76a4:	4564      	cmp	r4, ip
    76a6:	db07      	blt.n	76b8 <irep_exec+0x204>
    76a8:	008c      	lsls	r4, r1, #2
    76aa:	6841      	ldr	r1, [r0, #4]
    76ac:	0092      	lsls	r2, r2, #2
    76ae:	1909      	adds	r1, r1, r4
				if (op == OP_GETUPVAR) {
    76b0:	2b1f      	cmp	r3, #31
    76b2:	d104      	bne.n	76be <irep_exec+0x20a>
					reg[a] = s->reg[b];
    76b4:	680b      	ldr	r3, [r1, #0]
    76b6:	e7d4      	b.n	7662 <irep_exec+0x1ae>
					s = s->parent;
    76b8:	6800      	ldr	r0, [r0, #0]
				for (int iu = 0; iu < c; iu++) {
    76ba:	3401      	adds	r4, #1
    76bc:	e7f2      	b.n	76a4 <irep_exec+0x1f0>
					s->reg[b] = reg[a];
    76be:	58ab      	ldr	r3, [r5, r2]
    76c0:	600b      	str	r3, [r1, #0]
    76c2:	e7c3      	b.n	764c <irep_exec+0x198>
				p = porg + a;
    76c4:	7832      	ldrb	r2, [r6, #0]
    76c6:	7873      	ldrb	r3, [r6, #1]
					p = porg + b;
    76c8:	021b      	lsls	r3, r3, #8
    76ca:	4313      	orrs	r3, r2
    76cc:	ba5b      	rev16	r3, r3
    76ce:	b29e      	uxth	r6, r3
    76d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    76d2:	199e      	adds	r6, r3, r6
    76d4:	e7ba      	b.n	764c <irep_exec+0x198>
				if ((op == OP_JMPIF) == (reg[a] != MRB_NIL)) {
    76d6:	2180      	movs	r1, #128	; 0x80
    76d8:	3b22      	subs	r3, #34	; 0x22
    76da:	1e5a      	subs	r2, r3, #1
    76dc:	4193      	sbcs	r3, r2
				a = *p++; b = *p++; b = (b << 8) | *p++;
    76de:	7862      	ldrb	r2, [r4, #1]
				if ((op == OP_JMPIF) == (reg[a] != MRB_NIL)) {
    76e0:	0609      	lsls	r1, r1, #24
    76e2:	0092      	lsls	r2, r2, #2
    76e4:	5952      	ldr	r2, [r2, r5]
				a = *p++; b = *p++; b = (b << 8) | *p++;
    76e6:	1d26      	adds	r6, r4, #4
				if ((op == OP_JMPIF) == (reg[a] != MRB_NIL)) {
    76e8:	1852      	adds	r2, r2, r1
    76ea:	1e51      	subs	r1, r2, #1
    76ec:	418a      	sbcs	r2, r1
    76ee:	4293      	cmp	r3, r2
    76f0:	d0ac      	beq.n	764c <irep_exec+0x198>
					p = porg + b;
    76f2:	78a2      	ldrb	r2, [r4, #2]
    76f4:	78e3      	ldrb	r3, [r4, #3]
    76f6:	e7e7      	b.n	76c8 <irep_exec+0x214>
				a = *p++; b = *p++; c = *p++;
    76f8:	7863      	ldrb	r3, [r4, #1]
    76fa:	78a2      	ldrb	r2, [r4, #2]
				const char* func = (const char*)(irep_get(irep, IREP_TYPE_SYMBOL, b) + 2);
    76fc:	2102      	movs	r1, #2
    76fe:	6af8      	ldr	r0, [r7, #44]	; 0x2c
				a = *p++; b = *p++; c = *p++;
    7700:	623b      	str	r3, [r7, #32]
				const char* func = (const char*)(irep_get(irep, IREP_TYPE_SYMBOL, b) + 2);
    7702:	f7ff fd81 	bl	7208 <irep_get>
    7706:	1c83      	adds	r3, r0, #2
				intptr_t* send2 = mrb_memory_find(vm, MRB_OBJ_OBJECT, func);
    7708:	001a      	movs	r2, r3
    770a:	2101      	movs	r1, #1
    770c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
				a = *p++; b = *p++; c = *p++;
    770e:	1d26      	adds	r6, r4, #4
				const char* func = (const char*)(irep_get(irep, IREP_TYPE_SYMBOL, b) + 2);
    7710:	60fb      	str	r3, [r7, #12]
				intptr_t* send2 = mrb_memory_find(vm, MRB_OBJ_OBJECT, func);
    7712:	f7ff fdf1 	bl	72f8 <mrb_memory_find>
				if (send2) {
    7716:	2800      	cmp	r0, #0
    7718:	d009      	beq.n	772e <irep_exec+0x27a>
					reg[a] = irep_exec(vm, (const uint8_t*)send2[2], &state, a);
    771a:	2234      	movs	r2, #52	; 0x34
    771c:	6a3b      	ldr	r3, [r7, #32]
    771e:	6881      	ldr	r1, [r0, #8]
    7720:	18ba      	adds	r2, r7, r2
    7722:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    7724:	f7ff fec6 	bl	74b4 <irep_exec>
    7728:	6a3b      	ldr	r3, [r7, #32]
				reg[a] = (intptr_t)irep_get(irep, IREP_TYPE_IREP, b);
    772a:	009b      	lsls	r3, r3, #2
    772c:	e7a4      	b.n	7678 <irep_exec+0x1c4>
				a = *p++; b = *p++; c = *p++;
    772e:	78e3      	ldrb	r3, [r4, #3]
				emb_method(vm, func, reg, a, c);
    7730:	002a      	movs	r2, r5
				a = *p++; b = *p++; c = *p++;
    7732:	9300      	str	r3, [sp, #0]
				emb_method(vm, func, reg, a, c);
    7734:	6a3b      	ldr	r3, [r7, #32]
    7736:	68f9      	ldr	r1, [r7, #12]
    7738:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    773a:	f7ff fe19 	bl	7370 <emb_method>
				break;
    773e:	e785      	b.n	764c <irep_exec+0x198>
				const char* funcb = (const char*)(irep_get(irep, IREP_TYPE_SYMBOL, b) + 2);
    7740:	2102      	movs	r1, #2
				a = *p++; b = *p++; c = *p++;
    7742:	78a2      	ldrb	r2, [r4, #2]
				const char* funcb = (const char*)(irep_get(irep, IREP_TYPE_SYMBOL, b) + 2);
    7744:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    7746:	f7ff fd5f 	bl	7208 <irep_get>
				if (mrb_strcmp(funcb, "times") == 0) {
    774a:	4925      	ldr	r1, [pc, #148]	; (77e0 <irep_exec+0x32c>)
				const char* funcb = (const char*)(irep_get(irep, IREP_TYPE_SYMBOL, b) + 2);
    774c:	3002      	adds	r0, #2
				a = *p++; b = *p++; c = *p++;
    774e:	1d26      	adds	r6, r4, #4
				if (mrb_strcmp(funcb, "times") == 0) {
    7750:	f7ff fdc7 	bl	72e2 <mrb_strcmp>
    7754:	2800      	cmp	r0, #0
    7756:	d000      	beq.n	775a <irep_exec+0x2a6>
    7758:	e778      	b.n	764c <irep_exec+0x198>
    775a:	7864      	ldrb	r4, [r4, #1]
	struct mrb_state state = { .parent = parent, .reg = reg };
    775c:	2230      	movs	r2, #48	; 0x30
    775e:	00a4      	lsls	r4, r4, #2
    7760:	192c      	adds	r4, r5, r4
					reg[a] = num_times(vm, reg[a], (const uint8_t*)reg[a + 1], &state);
    7762:	6823      	ldr	r3, [r4, #0]
	struct mrb_state state = { .parent = parent, .reg = reg };
    7764:	18ba      	adds	r2, r7, r2
					reg[a] = num_times(vm, reg[a], (const uint8_t*)reg[a + 1], &state);
    7766:	60fb      	str	r3, [r7, #12]
    7768:	6863      	ldr	r3, [r4, #4]
	for (int i = 0; i < n; i++) {
    776a:	6238      	str	r0, [r7, #32]
					reg[a] = num_times(vm, reg[a], (const uint8_t*)reg[a + 1], &state);
    776c:	607b      	str	r3, [r7, #4]
	struct mrb_state state = { .parent = parent, .reg = reg };
    776e:	2334      	movs	r3, #52	; 0x34
    7770:	18fb      	adds	r3, r7, r3
    7772:	63fb      	str	r3, [r7, #60]	; 0x3c
    7774:	2314      	movs	r3, #20
    7776:	18d3      	adds	r3, r2, r3
    7778:	643b      	str	r3, [r7, #64]	; 0x40
	reg[0] = MRB_NIL;
    777a:	2380      	movs	r3, #128	; 0x80
    777c:	061b      	lsls	r3, r3, #24
    777e:	647b      	str	r3, [r7, #68]	; 0x44
	for (int i = 0; i < n; i++) {
    7780:	68fb      	ldr	r3, [r7, #12]
    7782:	6a3a      	ldr	r2, [r7, #32]
    7784:	4293      	cmp	r3, r2
    7786:	dc01      	bgt.n	778c <irep_exec+0x2d8>
				reg[a] /= reg[a + 1];
    7788:	6020      	str	r0, [r4, #0]
				break;
    778a:	e75f      	b.n	764c <irep_exec+0x198>
		ret = irep_exec(vm, irep, &state, 1);
    778c:	2130      	movs	r1, #48	; 0x30
    778e:	220c      	movs	r2, #12
		reg[1] = i;
    7790:	6a3b      	ldr	r3, [r7, #32]
		ret = irep_exec(vm, irep, &state, 1);
    7792:	1879      	adds	r1, r7, r1
		reg[1] = i;
    7794:	64bb      	str	r3, [r7, #72]	; 0x48
		ret = irep_exec(vm, irep, &state, 1);
    7796:	188a      	adds	r2, r1, r2
    7798:	2301      	movs	r3, #1
    779a:	6879      	ldr	r1, [r7, #4]
    779c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    779e:	f7ff fe89 	bl	74b4 <irep_exec>
	for (int i = 0; i < n; i++) {
    77a2:	6a3b      	ldr	r3, [r7, #32]
    77a4:	3301      	adds	r3, #1
    77a6:	623b      	str	r3, [r7, #32]
    77a8:	e7ea      	b.n	7780 <irep_exec+0x2cc>
				a = *p++; a = (a << 8) | *p++; a = (a << 8) | *p++;
    77aa:	7873      	ldrb	r3, [r6, #1]
    77ac:	7832      	ldrb	r2, [r6, #0]
    77ae:	021b      	lsls	r3, r3, #8
    77b0:	4313      	orrs	r3, r2
    77b2:	ba5b      	rev16	r3, r3
    77b4:	69fa      	ldr	r2, [r7, #28]
    77b6:	b29b      	uxth	r3, r3
    77b8:	3201      	adds	r2, #1
				int nparam = a >> 18; // no checks now
    77ba:	0a9b      	lsrs	r3, r3, #10
    77bc:	189b      	adds	r3, r3, r2
				for (int i = 0; i < nparam; i++) {
    77be:	697a      	ldr	r2, [r7, #20]
				a = *p++; a = (a << 8) | *p++; a = (a << 8) | *p++;
    77c0:	1d26      	adds	r6, r4, #4
    77c2:	009b      	lsls	r3, r3, #2
    77c4:	3204      	adds	r2, #4
				for (int i = 0; i < nparam; i++) {
    77c6:	4293      	cmp	r3, r2
    77c8:	d100      	bne.n	77cc <irep_exec+0x318>
    77ca:	e73f      	b.n	764c <irep_exec+0x198>
					reg[i + 1] = parent->reg[i + 1 + paramreg];
    77cc:	69b9      	ldr	r1, [r7, #24]
    77ce:	6849      	ldr	r1, [r1, #4]
    77d0:	5889      	ldr	r1, [r1, r2]
    77d2:	6239      	str	r1, [r7, #32]
    77d4:	6a38      	ldr	r0, [r7, #32]
    77d6:	68b9      	ldr	r1, [r7, #8]
    77d8:	5088      	str	r0, [r1, r2]
    77da:	e7f3      	b.n	77c4 <irep_exec+0x310>
    77dc:	0000793d 	.word	0x0000793d
    77e0:	00007942 	.word	0x00007942
				a = *p++;
    77e4:	7863      	ldrb	r3, [r4, #1]
				return reg[a];
    77e6:	009b      	lsls	r3, r3, #2
    77e8:	5958      	ldr	r0, [r3, r5]
}
    77ea:	46bd      	mov	sp, r7
    77ec:	b015      	add	sp, #84	; 0x54
    77ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    77f0:	7863      	ldrb	r3, [r4, #1]
				a = *p++;
    77f2:	1ca6      	adds	r6, r4, #2
    77f4:	009b      	lsls	r3, r3, #2
    77f6:	18eb      	adds	r3, r5, r3
				reg[a] += reg[a + 1];
    77f8:	681a      	ldr	r2, [r3, #0]
    77fa:	6859      	ldr	r1, [r3, #4]
				reg[a] += b;
    77fc:	188a      	adds	r2, r1, r2
				vm->err = MRB_ERR_UNSUPPORTED_OPCODE;
    77fe:	601a      	str	r2, [r3, #0]
				break;
    7800:	e724      	b.n	764c <irep_exec+0x198>
    7802:	7863      	ldrb	r3, [r4, #1]
				a = *p++; b = *p++;
    7804:	1ce6      	adds	r6, r4, #3
    7806:	009b      	lsls	r3, r3, #2
    7808:	18eb      	adds	r3, r5, r3
    780a:	78a2      	ldrb	r2, [r4, #2]
				reg[a] += b;
    780c:	6819      	ldr	r1, [r3, #0]
    780e:	e7f5      	b.n	77fc <irep_exec+0x348>
    7810:	7863      	ldrb	r3, [r4, #1]
				a = *p++;
    7812:	1ca6      	adds	r6, r4, #2
    7814:	009b      	lsls	r3, r3, #2
    7816:	18eb      	adds	r3, r5, r3
				reg[a] -= reg[a + 1];
    7818:	681a      	ldr	r2, [r3, #0]
    781a:	6859      	ldr	r1, [r3, #4]
    781c:	1a52      	subs	r2, r2, r1
    781e:	e7ee      	b.n	77fe <irep_exec+0x34a>
    7820:	7863      	ldrb	r3, [r4, #1]
				a = *p++; b = *p++;
    7822:	78a2      	ldrb	r2, [r4, #2]
    7824:	009b      	lsls	r3, r3, #2
    7826:	18eb      	adds	r3, r5, r3
				reg[a] -= b;
    7828:	6819      	ldr	r1, [r3, #0]
				a = *p++; b = *p++;
    782a:	1ce6      	adds	r6, r4, #3
				reg[a] -= b;
    782c:	1a8a      	subs	r2, r1, r2
    782e:	e7e6      	b.n	77fe <irep_exec+0x34a>
    7830:	7863      	ldrb	r3, [r4, #1]
				a = *p++;
    7832:	1ca6      	adds	r6, r4, #2
    7834:	009b      	lsls	r3, r3, #2
    7836:	18eb      	adds	r3, r5, r3
				reg[a] *= reg[a + 1];
    7838:	685a      	ldr	r2, [r3, #4]
    783a:	6819      	ldr	r1, [r3, #0]
    783c:	434a      	muls	r2, r1
    783e:	e7de      	b.n	77fe <irep_exec+0x34a>
				a = *p++;
    7840:	1ca6      	adds	r6, r4, #2
    7842:	7864      	ldrb	r4, [r4, #1]
    7844:	00a4      	lsls	r4, r4, #2
    7846:	192c      	adds	r4, r5, r4
				reg[a] /= reg[a + 1];
    7848:	6861      	ldr	r1, [r4, #4]
    784a:	6820      	ldr	r0, [r4, #0]
    784c:	f7ff fbf0 	bl	7030 <__divsi3>
    7850:	e79a      	b.n	7788 <irep_exec+0x2d4>
				reg[a] = reg[a] == reg[a + 1] ? MRB_TRUE : MRB_FALSE;
    7852:	2280      	movs	r2, #128	; 0x80
    7854:	7863      	ldrb	r3, [r4, #1]
				a = *p++;
    7856:	1ca6      	adds	r6, r4, #2
    7858:	009b      	lsls	r3, r3, #2
    785a:	18eb      	adds	r3, r5, r3
				reg[a] = reg[a] == reg[a + 1] ? MRB_TRUE : MRB_FALSE;
    785c:	6819      	ldr	r1, [r3, #0]
    785e:	6858      	ldr	r0, [r3, #4]
    7860:	0612      	lsls	r2, r2, #24
    7862:	4281      	cmp	r1, r0
    7864:	d1cb      	bne.n	77fe <irep_exec+0x34a>
				vm->err = MRB_ERR_UNSUPPORTED_OPCODE;
    7866:	2201      	movs	r2, #1
    7868:	e7c9      	b.n	77fe <irep_exec+0x34a>
				reg[a] = reg[a] < reg[a + 1] ? MRB_TRUE : MRB_FALSE;
    786a:	2280      	movs	r2, #128	; 0x80
    786c:	7863      	ldrb	r3, [r4, #1]
				a = *p++;
    786e:	1ca6      	adds	r6, r4, #2
    7870:	009b      	lsls	r3, r3, #2
    7872:	18eb      	adds	r3, r5, r3
				reg[a] = reg[a] < reg[a + 1] ? MRB_TRUE : MRB_FALSE;
    7874:	6819      	ldr	r1, [r3, #0]
    7876:	6858      	ldr	r0, [r3, #4]
    7878:	0612      	lsls	r2, r2, #24
    787a:	4281      	cmp	r1, r0
    787c:	dabf      	bge.n	77fe <irep_exec+0x34a>
    787e:	e7f2      	b.n	7866 <irep_exec+0x3b2>
				reg[a] = reg[a] <= reg[a + 1] ? MRB_TRUE : MRB_FALSE;
    7880:	2280      	movs	r2, #128	; 0x80
    7882:	7863      	ldrb	r3, [r4, #1]
				a = *p++;
    7884:	1ca6      	adds	r6, r4, #2
    7886:	009b      	lsls	r3, r3, #2
    7888:	18eb      	adds	r3, r5, r3
				reg[a] = reg[a] <= reg[a + 1] ? MRB_TRUE : MRB_FALSE;
    788a:	6819      	ldr	r1, [r3, #0]
    788c:	6858      	ldr	r0, [r3, #4]
    788e:	0612      	lsls	r2, r2, #24
    7890:	4281      	cmp	r1, r0
    7892:	dcb4      	bgt.n	77fe <irep_exec+0x34a>
    7894:	e7e7      	b.n	7866 <irep_exec+0x3b2>
				reg[a] = reg[a] > reg[a + 1] ? MRB_TRUE : MRB_FALSE;
    7896:	2280      	movs	r2, #128	; 0x80
    7898:	7863      	ldrb	r3, [r4, #1]
				a = *p++;
    789a:	1ca6      	adds	r6, r4, #2
    789c:	009b      	lsls	r3, r3, #2
    789e:	18eb      	adds	r3, r5, r3
				reg[a] = reg[a] > reg[a + 1] ? MRB_TRUE : MRB_FALSE;
    78a0:	6819      	ldr	r1, [r3, #0]
    78a2:	6858      	ldr	r0, [r3, #4]
    78a4:	0612      	lsls	r2, r2, #24
    78a6:	4281      	cmp	r1, r0
    78a8:	dda9      	ble.n	77fe <irep_exec+0x34a>
    78aa:	e7dc      	b.n	7866 <irep_exec+0x3b2>
				reg[a] = reg[a] >= reg[a + 1] ? MRB_TRUE : MRB_FALSE;
    78ac:	2280      	movs	r2, #128	; 0x80
    78ae:	7863      	ldrb	r3, [r4, #1]
				a = *p++;
    78b0:	1ca6      	adds	r6, r4, #2
    78b2:	009b      	lsls	r3, r3, #2
    78b4:	18eb      	adds	r3, r5, r3
				reg[a] = reg[a] >= reg[a + 1] ? MRB_TRUE : MRB_FALSE;
    78b6:	6819      	ldr	r1, [r3, #0]
    78b8:	6858      	ldr	r0, [r3, #4]
    78ba:	0612      	lsls	r2, r2, #24
    78bc:	4281      	cmp	r1, r0
    78be:	db9e      	blt.n	77fe <irep_exec+0x34a>
    78c0:	e7d1      	b.n	7866 <irep_exec+0x3b2>
				a = *p++; b = *p++;
    78c2:	1ce6      	adds	r6, r4, #3
    78c4:	78a2      	ldrb	r2, [r4, #2]
				reg[a] = (intptr_t)irep_get(irep, IREP_TYPE_LITERAL, b) + 2;
    78c6:	2101      	movs	r1, #1
    78c8:	e6d0      	b.n	766c <irep_exec+0x1b8>
				a = *p++;
    78ca:	1ca6      	adds	r6, r4, #2
				break;
    78cc:	e6be      	b.n	764c <irep_exec+0x198>
				a = *p++; b = *p++;
    78ce:	78a2      	ldrb	r2, [r4, #2]
				reg[a] = (intptr_t)irep_get(irep, IREP_TYPE_IREP, b);
    78d0:	2103      	movs	r1, #3
    78d2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
				a = *p++; b = *p++;
    78d4:	1ce6      	adds	r6, r4, #3
				reg[a] = (intptr_t)irep_get(irep, IREP_TYPE_IREP, b);
    78d6:	f7ff fc97 	bl	7208 <irep_get>
    78da:	e6a6      	b.n	762a <irep_exec+0x176>
				a = *p++; b = *p++;
    78dc:	78a2      	ldrb	r2, [r4, #2]
				const char* funcm = (const char*)(irep_get(irep, IREP_TYPE_SYMBOL, b) + 2);
    78de:	2102      	movs	r1, #2
    78e0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    78e2:	f7ff fc91 	bl	7208 <irep_get>
    78e6:	7861      	ldrb	r1, [r4, #1]
    78e8:	1c82      	adds	r2, r0, #2
    78ea:	0089      	lsls	r1, r1, #2
    78ec:	1869      	adds	r1, r5, r1
				mrb_memory_add(vm, reg[a], funcm, reg[a + 1]);
    78ee:	684b      	ldr	r3, [r1, #4]
    78f0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    78f2:	6809      	ldr	r1, [r1, #0]
				a = *p++; b = *p++;
    78f4:	1ce6      	adds	r6, r4, #3
				mrb_memory_add(vm, reg[a], funcm, reg[a + 1]);
    78f6:	f7ff fd1c 	bl	7332 <mrb_memory_add>
				break;
    78fa:	e6a7      	b.n	764c <irep_exec+0x198>
				a = *p++;
    78fc:	7863      	ldrb	r3, [r4, #1]
    78fe:	1ca6      	adds	r6, r4, #2
				reg[a] = reg[0]; // ??
    7900:	009b      	lsls	r3, r3, #2
    7902:	682a      	ldr	r2, [r5, #0]
    7904:	e686      	b.n	7614 <irep_exec+0x160>
				opext = op - OP_EXT1 + 1;
    7906:	3b63      	subs	r3, #99	; 0x63
    7908:	613b      	str	r3, [r7, #16]
				break;
    790a:	e69f      	b.n	764c <irep_exec+0x198>
				vm->err = MRB_ERR_UNSUPPORTED_OPCODE;
    790c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    790e:	e7aa      	b.n	7866 <irep_exec+0x3b2>
				return 0;
    7910:	2000      	movs	r0, #0
    7912:	e76a      	b.n	77ea <irep_exec+0x336>
